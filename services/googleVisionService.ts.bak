// services/googleVisionService.ts
// Service de mesure utilisant Google Cloud Vision API

import { ImageAnnotatorClient } from '@google-cloud/vision';

export interface GoogleVisionResult {
  dimensions: {
    length: number;
    width: number;
    height: number;
  };
  confidence: number;
  reasoning: string;
  boundingBox?: any;
}

export class GoogleVisionService {
  private client!: ImageAnnotatorClient;

  constructor() {
    this.client = new ImageAnnotatorClient({
      // Les credentials seront lues depuis GOOGLE_APPLICATION_CREDENTIALS
    });
  }

  /**
   * Mesure un objet avec Google Cloud Vision
   */
  async measureObject(imageUrl: string, objectLabel: string): Promise<GoogleVisionResult> {
    try {
      console.log(`üîç Google Vision: Mesure de ${objectLabel}...`);
      
      // 1. D√©tection d'objets
      const [result] = await this.client.objectLocalization({
        image: { source: { imageUri: imageUrl } }
      });

      // 2. Extraction des dimensions depuis les bounding boxes
      const dimensions = this.extractDimensionsFromBoundingBoxes(
        result.localizedObjectAnnotations || [],
        objectLabel
      );

      // 3. Validation et correction
      const validatedDimensions = this.validateDimensions(dimensions, objectLabel);

      return {
        dimensions: validatedDimensions,
        confidence: this.calculateConfidence(result.localizedObjectAnnotations || []),
        reasoning: `Google Vision: D√©tection bas√©e sur ${result.localizedObjectAnnotations?.length || 0} objets`,
        boundingBox: result.localizedObjectAnnotations?.[0]?.boundingPoly
      };

    } catch (error) {
      console.error('Erreur Google Vision:', error);
      
      // Fallback vers dimensions par d√©faut
      return this.getFallbackDimensions(objectLabel);
    }
  }

  /**
   * Extrait les dimensions depuis les bounding boxes
   */
  private extractDimensionsFromBoundingBoxes(
    annotations: any[],
    targetLabel: string
  ): { length: number; width: number; height: number } {
    // Chercher l'objet correspondant au label
    const targetObject = annotations.find(annotation => 
      annotation.name?.toLowerCase().includes(targetLabel.toLowerCase()) ||
      targetLabel.toLowerCase().includes(annotation.name?.toLowerCase())
    );

    if (!targetObject?.boundingPoly?.normalizedVertices) {
      return { length: 0, width: 0, height: 0 };
    }

    const vertices = targetObject.boundingPoly.normalizedVertices;
    
    // Calculer les dimensions normalis√©es
    const minX = Math.min(...vertices.map((v: any) => v.x || 0));
    const maxX = Math.max(...vertices.map((v: any) => v.x || 0));
    const minY = Math.min(...vertices.map((v: any) => v.y || 0));
    const maxY = Math.max(...vertices.map((v: any) => v.y || 0));

    const normalizedWidth = maxX - minX;
    const normalizedHeight = maxY - minY;

    // Convertir en dimensions r√©elles (estimation bas√©e sur des r√©f√©rences)
    // On assume une image de 1000x1000px pour la conversion
    const estimatedWidth = normalizedWidth * 1000; // cm
    const estimatedHeight = normalizedHeight * 1000; // cm
    const estimatedDepth = Math.min(estimatedWidth, estimatedHeight) * 0.6; // Estimation de profondeur

    return {
      length: Math.round(estimatedWidth),
      width: Math.round(estimatedDepth),
      height: Math.round(estimatedHeight)
    };
  }

  /**
   * Valide et corrige les dimensions
   */
  private validateDimensions(
    dimensions: { length: number; width: number; height: number },
    objectLabel: string
  ): { length: number; width: number; height: number } {
    let { length, width, height } = dimensions;

    // R√®gles de validation par type d'objet
    if (objectLabel.toLowerCase().includes('chaise')) {
      // Chaises: 40-50cm large, 40-50cm profondeur, 80-90cm haut
      length = Math.max(40, Math.min(length, 60));
      width = Math.max(40, Math.min(width, 60));
      height = Math.max(70, Math.min(height, 100));
    } else if (objectLabel.toLowerCase().includes('table')) {
      // Tables: 60-80cm haut, largeur variable
      height = Math.max(60, Math.min(height, 80));
    } else if (objectLabel.toLowerCase().includes('armoire')) {
      // Armoires: 50-70cm profondeur, 180-220cm haut
      width = Math.max(50, Math.min(width, 70));
      height = Math.max(180, Math.min(height, 220));
    }

    // Validation g√©n√©rale
    length = Math.max(10, Math.min(length, 300));
    width = Math.max(10, Math.min(width, 200));
    height = Math.max(10, Math.min(height, 250));

    return { length, width, height };
  }

  /**
   * Calcule la confidence bas√©e sur les annotations
   */
  private calculateConfidence(annotations: any[]): number {
    if (annotations.length === 0) return 0.1;
    
    const avgScore = annotations.reduce((sum, ann) => sum + (ann.score || 0), 0) / annotations.length;
    return Math.min(avgScore * 1.2, 0.95); // Boost l√©g√®rement la confidence
  }

  /**
   * Dimensions de fallback par cat√©gorie
   */
  private getFallbackDimensions(objectLabel: string): GoogleVisionResult {
    const label = objectLabel.toLowerCase();
    
    if (label.includes('chaise')) {
      return {
        dimensions: { length: 45, width: 45, height: 85 },
        confidence: 0.3,
        reasoning: 'Fallback: Dimensions standard chaise'
      };
    } else if (label.includes('table')) {
      return {
        dimensions: { length: 120, width: 60, height: 75 },
        confidence: 0.3,
        reasoning: 'Fallback: Dimensions standard table'
      };
    } else if (label.includes('armoire')) {
      return {
        dimensions: { length: 200, width: 60, height: 200 },
        confidence: 0.3,
        reasoning: 'Fallback: Dimensions standard armoire'
      };
    } else {
      return {
        dimensions: { length: 100, width: 50, height: 80 },
        confidence: 0.3,
        reasoning: 'Fallback: Dimensions g√©n√©riques'
      };
    }
  }
}

// Instance singleton
export const googleVisionService = new GoogleVisionService();
